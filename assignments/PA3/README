README file for Programming Assignment 3 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile
 README
 cool.y
 bad.cl
 good.cl
 cool-tree.handcode.h
 cool-tree.cc		  -> [cool root]/src/PA3/cool-tree.cc
 cool-tree.aps		  -> [cool root]/src/PA3/cool-tree.aps
 dumptype.cc		  -> [cool root]/src/PA3/dumptype.cc
 handle_flags.c           -> [cool root]/src/PA3/handle_flags.cc
 parser-phase.cc	  -> [cool root]/src/PA3/parser-phase.cc
 stringtab.cc		  -> [cool root]/src/PA3/stringtab.cc
 tokens-lex.cc		  -> [cool root]/src/PA3/tokens-lex.cc
 tree.cc		  -> [cool root]/src/PA3/tree.cc
 utilities.cc		  -> [cool root]/src/PA3/utilities.cc
 *.d			  dependency files
 *.*			  other generated files

The include (.h) files for this assignment can be found in 
[cool root]/include/PA3

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.
    
	The README contains this info. Part of the assignment is to
	fill in the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and why
	your test cases are adequate. It is part of the assignment to
	clearly and concisely explain things in text as well as to comment
	your code. Just edit this file.

	cool.y is the skeleton for the parser specification that you
	are to write. It already contains productions for the program
	and the classes. Use them as an example to write the remaining
	productions.  You should also read the bison documentation.
	This skeleton will compile and run as is, but it doesn't
	do much.

	good.cl, bad.cl test a few features of the grammar. You should
	add tests to ensure that good.cl exercises every legal
	construction of the grammar and that bad.cl exercises as many
	different parsing errors as you can squeeze into one file.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.
        cool-tree.handcode.h is the handwritten extension to
        cool-tree.h.  If you read cool-tree.h and cool-tree.cc, you will
        note that there are "hooks" for extending the classes
        declarations.  Extending and modifying the tree package is
        discussed in the "Cool Tour", but you do not need to (and should
        not) modify the tree package for this assignment.

	tokens-lex.cc is a lexer capable of reading a token stream from
	console in the format produced by the lexer phase. DO NOT
	MODIFY.

        parser-phase.cc contains a driver to test the parser. DO NOT
        MODIFY.

	dumptype.cc prints the AST out in a form readable by the
	semant phase of the compiler. DO NOT MODIFY.

	handle_flags.cc implements routines for parsing command line
        flags. DO NOT MODIFY.

        The rest of the files are created as byproducts of `bison'.
        `cool-parse.cc' is the generated C++ file containing the
        parser.

	Files not discussed are covered in the README for PA2.

Instructions
------------

	To compile your parser program type:

	% make parser

	This produces an executable named "parser" which is standalone
	phase of the Cool compiler.  It requires lexer, semant, and cgen
	to do anything useful.

	To test your parser on a file 'foo.cl' type

	% myparser foo.cl

	myparser is a shell script that "glues" together lexer and
	parser using pipes.

	To run your parser on the files good.cl and bad.cl type:

	% make dotest

	To run the (provided) lexer and your parser on a file called test.cl type:

	% ./lexer test.cl | ./parser

	If you think your parser is correct and behaves like
	the one we wrote, you may want to run a COOL compiler using
	your parser:

	% mycoolc foo.cl

	To overwrite the default lexical analyzer with yours, replace 
	lexer (which is a symbolic link to the "official" lexer) with
        your lexer from PA2.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA3
----------------


	/*assignment is right associative*/    
	%right LET_STMT	
	%right ASSIGN
	%left NOT
	/*comparison operators are not associate*/
	%nonassoc LE '<' '=' 
	/*all the binary operators (including NOT) are left associative*/
	%left '+' '-'
	%left '*' '/'
	%left ISVOID
	%left '~'
	%left '@'
	%left '.'
	
	Precedence declarations
	-----------------------
	-----------------------
	There are maily three types of Precedence,
		1) Left associative
			Priority level of the precedence as follows,
					.
					@
					~
					ISVOID
					* /
					+ -
					< =
					NOT
				
		2) Right associative
			There are only two right associative precedence (LET & ASSIGN)
		3) Non associative
			Non associatve precedence are the precedece those have no priority.
			They are LE , < , =
		
		when the line number is higher, higher the precedence in the bison
		


	Grammer Rules
	-------------
	-------------
	* The type rules for cool programming language are defined in this section.
	* Each rule describes how to combine set of terminals and non-terminals together
	to produce a given non-terminal.

	<--descriptions of each rule--> 

	rule for program
	----------------
		This was already implemented in the skeleton.
		Program may consist of one or more classes.
		non-termnal class_list is used to describe one or more classes.

	rule for class_list
	-------------------
		This was already implemented in the skeleton.
		class list must contain at least one class or more.

	rule for class
	--------------
		This rule describes the productions of a class.
		There are two types of classes.
			01) without a specific parent
					priduction => class TYPE { feature_list };
					in this case, class 'Object' is the parent.
					it is added to the idtable.
			02) with a specific parent
					priduction => class TYPE inherits TYPE { feature_list };

		class contain zero or more features.
		non-terminal feature_list is used to describe these set of features.

		There can be errors in set of features or class definition or in both.
		If a error is found in either case, the input strig is skiped to end of 
		the class definition.
		Then the parsing is started again from that point. 

	rule for feature_list
	---------------------
		Feature list may be empty or contains one or more features.
		Features are seperated by a ','.
		If a error found in one feature, it is skiped and parsing is started from next feature.

	rule for a feature
	------------------
		There are three types of features.
			01) methods
					profuction for a method as follows,
						ID( [ formal_list ] ) : TYPE { expr }
					this requires list of formals and an expression.
			
			02) attributes withoud initilization

			03) initialized attributes
					profuction for initialized attributes as follows,
						ID : TYPE  <- expr 
					this requires an exprrssion

	rule for formal_list
	--------------------
		A formal list can be empty.
		Or it contains one or more comma seperated formals.

	rule for a formal
	-----------------
		Production for a formal as follows
			ID : TYPE
	
	rule for expression
	-------------------
		There are several types of expressions.
		Productions for each type of expressions are defined for type rules
		given in the cool-manual.
		non-terminal expr is used to discribe expressions.
		There are some special cases to mention.
			
			=>Type rules for dispatchers
				dispatchers conntains set of ',' seperated expressions.
				non-terminal comma_sep_expr is used to produce that.

				rule for comma_sep_expr
				-----------------------
					this set can be empty.
					Or else, it contains one or more expressions seperated by ','
			
			=>Type rule for block
				A block contains set of expressions seperated by ';'.
				It must contain at least one expression.
				The non-terminal at_least_one_expr used to produce that set.

				rule for at_least_one_expr
				--------------------------
					this list cannot be empty.
					it must contain at least one expression.
					in this list each expression is seperated by a';'
			
			=>Type rule for case
				production of a case as follows.
					case expr of branches esac				
				A case contains one or more branches.
				The non terminal case_list is used to discribe these set of branches.
				The non-terminal case_ describes a one branch
		
				rule for case_list
				------------------
					cas_list must contain at least one case
			
			=>Type rule for the LET
				let ID : TYPE [ <- expr ] [[, ID : TYPE [ <- expr ]]]* in expr

				grammer for the let expression as above, to implement this, a separate variable list should 
				be implemented.



		Test Cases & Correctness
		------------------------
		------------------------

		All pssible test cases are in the gool.cl and the bad.cl

		All possible testcases are giving the same results as the inbuild parser results.
		Parser is compiled without any confilcts. Therefore we can assume our parse is correct and the robust.
 


